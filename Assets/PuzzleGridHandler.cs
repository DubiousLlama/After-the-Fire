using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;
using UnityEngine.UI;
using Audio;

/*
 * This script handles the internal logic of the plant grid. It allows the player to place plants on a grid and calculates the mana generated by the plants. You should attach a new instance of the script to each puzzle in the game.
 * 
 * Available functions:
 * int CalculateMana() - Calculates the total mana generated by all plants on the grid.
 * void Place(string content) - Places a plant on the grid at the player's current position. Since we do not have a player yet, this function is untested. String must be a key in the plantRef dictionary.
 * void PlaceAbsolute(int x, int y, string content) - Places a plant on the grid at the specified position.
 * void PrintGrid() - Prints the contents of the grid to the console.
 * void GetContent(int x, int y) - Returns the content of the grid at the specified position.
 * 
 */

namespace GridHandler
{
    public class PuzzleGridHandler : MonoBehaviour
    {
        // public string[,] setup = { { "soil", "soil", "soil" } };

        public int height = 1;
        public int width = 3;

        Grid grid;
        float tileSize = 0.639204f; // size of each tile in the grid

        GameObject player;

        [Header("Prefabs")]
        public GameObject fertileSoil;
        public GameObject moonglow;
        public GameObject starleafTree;
        public GameObject pinepalm;

        AudioManager audioManager;



        Dictionary<string, Plant> plantRef; // plant name -> plant object


        private Transform location;

        private GameObject[,] tiles;
        private GameObject[,] plants;

        // private AudioManager audioManager;


        // Awake is called before the first frame update and before all Start functions
        void Awake()
        {
            grid = new Grid(height, width);

            // instantiate the tile grid to match the data grid
            tiles = new GameObject[height, width];
            plants = new GameObject[height, width];

            // Get the location of this gamebobect
            location = this.transform;

            // Instantiate a grid of soil made up of the fertileSoil prefab
            for (int i = 0; i < height; i++)
            {
                for (int j = 0; j < width; j++)
                {
                    tiles[i, j] = Instantiate(fertileSoil, new Vector3(this.transform.position.x + j * tileSize, this.transform.position.y + i * tileSize, 0), Quaternion.identity);
                }
            }

            if (player == null)
            {
                player = GameObject.Find("Player");
            }

            plantRef = definePlants();

            // runTest();
        }

        private void Start()
        {
            audioManager = AudioManager.instance;
        }

        // Define the names and types of all plants that can be placed on the grid
        private Dictionary<string, Plant> definePlants()
        {
            plantRef = new Dictionary<string, Plant>();
            plantRef.Add("moonglow", new Plant("moonglow", "bush"));
            plantRef.Add("starleaf tree", new Plant("starleaf tree", "tree"));
            plantRef.Add("pinepalm", new Plant("pinepalm", "bush"));

            return plantRef;
        }

        // Checks to see that the grid initializes correctly and that the CalculateMana function works
        
        public void setTile(int x, int y, GameObject tile)
        {
            Destroy(tiles[y, x]);
            tiles[y, x] = Instantiate(tile, new Vector3(this.transform.position.x + x * tileSize, this.transform.position.y + y * tileSize, 0), Quaternion.identity);
        
        }

        private void runTest()
        {
            Debug.Log("Debug Tile (should be soil): " + grid.GetContent(0, 0)); // soil

            PlaceAbsolute(0, 0, "moonglow");
            PlaceAbsolute(1, 0, "starleaf tree");
            PlaceAbsolute(2, 0, "moonglow");

            PrintGrid();
            Debug.Log("Debug Score (Should be 10): " + CalculateMana());
        }

        // Loops over the grid. For each plant contained in the Plant dictionary, it calls the Score function of that plant object.
        public int CalculateMana()
        {
            int mana = 0;
            for (int i = 0; i < grid.GetHeight(); i++)
            {
                for (int j = 0; j < grid.GetWidth(); j++)
                {
                    string content = grid.GetContent(i, j);
                    if (plantRef.TryGetValue(content, out Plant plant))
                    {
                        mana += plant.Score(j, i, grid, plantRef);
                        // Debug.Log("Plant: " + plant.name + " at " + j.ToString() + ", " + i.ToString() + " with score " + plant.Score(j, i, grid, plantRef));
                    }
                }
            }
            return mana;
        }

        // Places a plant on the grid at the player's current position
        public void Place(string content)
        {
            Vector2 tile = PositionToTile();
            if (tile.x == -1 && tile.y == -1)
            {
                Debug.Log("Player is not in the grid.");
                audioManager.TriggerSFX("HitRock");
                return;
            }

            if (content == "soil")
            {
                if (grid.GetContent((int)tile.y, (int)tile.x) == "soil")
                {
                    return;
                }
                else
                {
                    grid.SetContent((int)tile.y, (int)tile.x, "soil");
                    DestroyImmediate(plants[(int)tile.y, (int)tile.x]);
                    Debug.Log("Debug Score: " + CalculateMana());
                    return;
                }
            }

            // check if the content is a valid plant
            if (!plantRef.ContainsKey(content))
            {
                throw new ArgumentException("Invalid plant name.");
            }

            // Check if the tile is fertile soil
            if (tiles[(int)tile.y, (int)tile.x].tag != "Plantable")
            {
                Debug.Log("Tile is not fertile soil.");
                audioManager.TriggerSFX("HitRock");
                return;
            }

            if (grid.GetContent((int)tile.y, (int)tile.x) != "soil")
            {
                DestroyImmediate(plants[(int)tile.y, (int)tile.x]);
            }

            grid.SetContent((int)tile.y, (int)tile.x, content);
            plants[(int)tile.y, (int)tile.x] = InstantiatePlant(content, (int)tile.x, (int)tile.y);

            Debug.Log("Debug Score: " + CalculateMana());

            // Play the long dig for trees and the short dig for bushes
            if (plantRef[content].type == "tree")
            {
                audioManager.TriggerSFX("LongDig");
            }
            else
            {
                audioManager.TriggerSFX("ShortDig");
            }
        }

        // Places a plant on the grid at the specified position
        public void PlaceAbsolute(int x, int y, string content)
        {
            if (!plantRef.ContainsKey(content))
            {
                throw new ArgumentException("Invalid plant name.");
            }

            grid.SetContent(y, x, content);
            plants[y, x] = InstantiatePlant(content, x, y);
        }

        // Returns the content of the grid at the specified position
        public string GetContent(int x, int y)
        {
            return grid.GetContent(y, x);
        }

        // Prints the contents of the grid to the console
        public void PrintGrid()
        {
            for (int i = 0; i < grid.GetHeight(); i++)
            {
                for (int j = 0; j < grid.GetWidth(); j++)
                {
                    Debug.Log(j.ToString() + ", " + i.ToString() + ": " + grid.GetContent(i, j));
                }
            }
        }

        private GameObject InstantiatePlant(string plantName, int x, int y)
        {
            // Convert the grid position to a world position
            Vector3 position = new Vector3(this.transform.position.x + x * tileSize, this.transform.position.y + y * tileSize, -1);
            Debug.Log(x);
            Debug.Log(y);
            Vector3 lowerPlantOffset = new Vector3(0, 0, -0.01f);

            position = position + lowerPlantOffset * -y;

            Vector3 treeOffset = new Vector3(0, 0.25f, 0);

            Vector3 plantOffset = new Vector3(0, 0.12f, 0);



            if (plants[y, x] != null)
            {
                return null;
            }
            
            switch (plantName)
            {
                case "moonglow":
                    if (moonglow == null)
                    {
                        return null;
                    }
                    return Instantiate(moonglow, position + plantOffset, Quaternion.identity);
                case "starleaf tree":
                    if (starleafTree == null)
                    {
                        return null;
                    }
                    return Instantiate(starleafTree, position + treeOffset, Quaternion.identity);
                case "pinepalm":
                    if (pinepalm == null)
                    {
                        return null;
                    }
                    return Instantiate(pinepalm, position + plantOffset, Quaternion.identity);
                default:
                    return null;
            }
        }

        private void DestroyPlant(int x, int y)
        {
            Destroy(plants[y, x]);
        }

        // Converts the player's position to a tile on the grid
        private Vector2 PositionToTile()
        {
            if (player == null)
            {
                player = GameObject.Find("Player");
            }

            Vector3 playerPosition = player.transform.position;
            Vector2 notInGrid = new Vector2(-1, -1);

            // Find the player's position relative to the corner of the grid
            float relativeX = playerPosition.x - this.transform.position.x + 0.5f * tileSize;
            float relativeY = playerPosition.y - this.transform.position.y + 0.5f * tileSize;

            // Check if the player is inside the grid
            if (relativeX < 0 || relativeX >= grid.GetWidth() * tileSize || relativeY < 0 || relativeY >= grid.GetHeight() * tileSize)
            {
                return notInGrid;
            }

            // Find the player's position in terms of tiles
            int tileX = (int)(relativeX / tileSize);
            int tileY = (int)(relativeY / tileSize);

            return new Vector2(tileX, tileY);
        }

        //private void OnDestroy()
        //{
        //    foreach (GameObject tile in tiles)
        //    {
        //        Destroy(tile);
        //    }

        //    foreach (GameObject plant in plants)
        //    {
        //        Destroy(plant);
        //    }
        //}
    }

    // In hindsight I think this maybe should have all been included in the main placement tracker script, but I'm too lazy to change it now.
    // This class proivides some basic useful functions for working with a grid beyond what I would get from a 2D array.
    class Grid
    {
        private string[,] grid;

        public Grid(int height, int width)
        {
            grid = new string[height, width];
            for (int i = 0; i < GetHeight(); i++)
            {
                for (int j = 0; j < GetWidth(); j++)
                {
                    grid[i, j] = "soil";
                }
            }
        }

        public void setGrid(string[,] grid)
        {
            if (grid.GetLength(0) != GetHeight() || grid.GetLength(1) != GetWidth())
            {
                throw new ArgumentException("The new grid must have the same dimensions as the old grid.");
            }

            this.grid = grid;
        }

        public int GetHeight()
        {
            return grid.GetLength(0);
        }

        public int GetWidth()
        {
            return grid.GetLength(1);
        }

        public string GetContent(int row, int col)
        {
            if (row < 0 || row >= GetHeight() || col < 0 || col >= GetWidth())
            {
                return "out of bounds";
            }
            return grid[row, col];
        }

        public void SetContent(int row, int col, string content)
        {
            if (row < 0 || row >= GetHeight() || col < 0 || col >= GetWidth())
            {
                throw new ArgumentOutOfRangeException("Row or column is out of the grid's bounds.");
            }
            grid[row, col] = content;
        }
    }

    // This really should be a parent class with subclasses for each type of plant, but I'm lazy so instead you get a switch statement.
    // Plants must have a name and a type. The Score function calculates the mana generated by the plant at the specified position.
    // When you add a new plant, you must add a case to the switch statement in the Score function.
    class Plant
    {
        public string name;
        public string type;

        public Plant(string name, string type)
        {
            this.name = name;
            this.type = type;
        }

        public int Score(int x, int y, Grid grid, Dictionary<string, Plant> plantRef)
        {

            Vector2[] directions = { new Vector2(0, 1), new Vector2(1, 0), new Vector2(0, -1), new Vector2(-1, 0) };

            switch (name)
            { 
                case "moonglow":
                    return 3;
                case "starleaf tree":
                    // Get the number of adjacent bushes
                    int count = 0;

                    foreach (Vector2 dir in directions)
                    {
                        if (plantRef.TryGetValue(grid.GetContent(y + (int)dir.y, x + (int)dir.x), out Plant plant))
                        {
                            if (plant.type == "bush")
                            {
                                count++;
                            }
                        }
                    }
                    return 2 * count;
                case "pinepalm":
                    // Return the number of adjacent plants with different names
                    HashSet<string> names = new HashSet<string>();

                    foreach (Vector2 dir in directions)
                    {
                        if (plantRef.TryGetValue(grid.GetContent(y + (int)dir.y, x + (int)dir.x), out Plant plant))
                        {
                            if (plant.name != "soil" && plant.name != "pinepalm")
                            {
                                names.Add(plant.name);
                            }
                            
                        }
                    }
                    if (names.Count > 1)
                    {
                        return 5;
                    }
                    else
                    {
                        return 0;
                    }
                default:
                    return 0;
            }
        }
    }
}
