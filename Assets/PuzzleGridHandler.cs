using System;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

/*
 * This script handles the internal logic of the plant grid. It allows the player to place plants on a grid and calculates the mana generated by the plants. You should attach a new instance of the script to each puzzle in the game.
 * 
 * Available functions:
 * int CalculateMana() - Calculates the total mana generated by all plants on the grid.
 * void Place(string content) - Places a plant on the grid at the player's current position. Since we do not have a player yet, this function is untested. String must be a key in the plantRef dictionary.
 * void PlaceAbsolute(int x, int y, string content) - Places a plant on the grid at the specified position.
 * void PrintGrid() - Prints the contents of the grid to the console.
 * void GetContent(int x, int y) - Returns the content of the grid at the specified position.
 * 
 */

public class PuzzleGridHandler : MonoBehaviour
{
    // public string[,] setup = { { "soil", "soil", "soil" } };

    public int height = 1;
    public int width = 3;
    public float gridX = 0.0f;
    public float gridY = 0.0f;

    Grid grid;
    float tileSize = 1.0f; // size of each tile in the grid

    GameObject player;

    Dictionary<string, Plant> plantRef; // plant name -> plant object

    // Start is called before the first frame update
    void Start()
    {
        grid = new Grid(height, width);

        if (player == null)
        {
            player = GameObject.Find("Player");
        }

        plantRef = definePlants();

        runTest();

    }

    // Define the names and types of all plants that can be placed on the grid
    private Dictionary<string, Plant> definePlants()
    {
        plantRef = new Dictionary<string, Plant>();
        plantRef.Add("moonglow", new Plant("moonglow", "bush"));
        plantRef.Add("starleaf tree", new Plant("starleaf tree", "tree"));

        return plantRef;
    }

    // Checks to see that the grid initializes correctly and that the CalculateMana function works
    private void runTest()
    {
        Debug.Log(grid.GetContent(0, 0)); // soil

        PlaceAbsolute(0, 0, "moonglow");
        PlaceAbsolute(1, 0, "starleaf tree");
        PlaceAbsolute(2, 0, "moonglow");

        PrintGrid();
        Debug.Log(CalculateMana());
    }

    // Loops over the grid. For each plant contained in the Plant dictionary, it calls the Score function of that plant object.
    public int CalculateMana()
    {
        int mana = 0;
        for (int i = 0; i < grid.GetHeight(); i++)
        {
            for (int j = 0; j < grid.GetWidth(); j++)
            {
                string content = grid.GetContent(i, j);
                if (plantRef.TryGetValue(content, out Plant plant))
                {
                    mana += plant.Score(j, i, grid, plantRef);
                    // Debug.Log("Plant: " + plant.name + " at " + j.ToString() + ", " + i.ToString() + " with score " + plant.Score(j, i, grid, plantRef));
                }
            }
        }
        return mana;
    }

    // Places a plant on the grid at the player's current position
    public void Place(string content)
    {
        if (player == null)
        {
            player = GameObject.Find("Player");
        }

        // check if the content is a valid plant
        if (!plantRef.ContainsKey(content))
        {
            throw new ArgumentException("Invalid plant name.");
        }

        Vector2 tile = PositionToTile();
        if (tile.x == -1 && tile.y == -1)
        {
            return;
        }

        grid.SetContent((int)tile.y, (int)tile.x, content);
    }

    // Places a plant on the grid at the specified position
    public void PlaceAbsolute(int x, int y, string content)
    {
        if (!plantRef.ContainsKey(content))
        {
            throw new ArgumentException("Invalid plant name.");
        }

        grid.SetContent(y, x, content);
    }

    // Returns the content of the grid at the specified position
    public string GetContent(int x, int y)
    {
        return grid.GetContent(y, x);
    }

    // Prints the contents of the grid to the console
    public void PrintGrid() {
        for (int i = 0; i < grid.GetHeight(); i++)
        {
            for (int j = 0; j < grid.GetWidth(); j++)
            {
                Debug.Log(j.ToString() + ", " + i.ToString() + ": " + grid.GetContent(i, j));
            }
        }
    }

    // Converts the player's position to a tile on the grid
    private Vector2 PositionToTile()
    {
        Vector3 playerPosition = player.transform.position;
        Vector2 notInGrid = new Vector2(-1, -1);
        
        // Find the player's position relative to the corner of the grid
        float relativeX = playerPosition.x - gridX;
        float relativeY = playerPosition.y - gridY;

        // Check if the player is inside the grid
        if (relativeX < 0 || relativeX >= grid.GetWidth() * tileSize || relativeY < 0 || relativeY >= grid.GetHeight() * tileSize)
        {
            return notInGrid;
        }

        // Find the player's position in terms of tiles
        int tileX = (int)(relativeX / tileSize);
        int tileY = (int)(relativeY / tileSize);

        return new Vector2(tileX, tileY);
    }
}

// In hindsight I think this maybe should have all been included in the main placement tracker script, but I'm too lazy to change it now.
// This class proivides some basic useful functions for working with a grid beyond what I would get from a 2D array.
class Grid
{
    private string[,] grid;

    public Grid(int height, int width)
    {
        grid = new string[height, width];
        for (int i = 0; i < GetHeight(); i++)
        {
            for (int j = 0; j < GetWidth(); j++)
            {
                grid[i, j] = "soil";
            }
        }
    }

    public void setGrid(string[,] grid)
    {
        if (grid.GetLength(0) != GetHeight() || grid.GetLength(1) != GetWidth())
        {
            throw new ArgumentException("The new grid must have the same dimensions as the old grid.");
        }

        this.grid = grid;
    }

    public int GetHeight()
    {
        return grid.GetLength(0);
    }

    public int GetWidth()
    {
        return grid.GetLength(1);
    }

    public string GetContent(int row, int col)
    {
        if (row < 0 || row >= GetHeight() || col < 0 || col >= GetWidth())
        {
            return "out of bounds";
        }
        return grid[row, col];
    }

    public void SetContent(int row, int col, string content)
    {
        if (row < 0 || row >= GetHeight() || col < 0 || col >= GetWidth())
        {
            throw new ArgumentOutOfRangeException("Row or column is out of the grid's bounds.");
        }
        grid[row, col] = content;
    }
}

// This really should be a parent class with subclasses for each type of plant, but I'm lazy so instead you get a switch statement.
// Plants must have a name and a type. The Score function calculates the mana generated by the plant at the specified position.
// When you add a new plant, you must add a case to the switch statement in the Score function.
class Plant
{
    public string name;
    public string type;

    public Plant(string name, string type)
    {
        this.name = name;
        this.type = type;
    }

    public int Score(int x, int y, Grid grid, Dictionary<string, Plant> plantRef)
    {

       Vector2[] directions = { new Vector2(0, 1), new Vector2(1, 0), new Vector2(0, -1), new Vector2(-1, 0) };
       
       switch (name) {
            case "moonglow":
                Debug.Log("Scoring Moonglow");
                return 3;
            case "starleaf tree":
                // Get the number of adjacent bushes
                int count = 0;
                
                foreach (Vector2 dir in directions) {
                    if (plantRef.TryGetValue(grid.GetContent(x + (int)dir.x, y + (int)dir.y), out Plant plant))
                    {
                        if (plant.type == "bush")
                        {
                            count++;
                        }
                    }
                }
                return 2*count;

            default:
                return 0;
        }
    }
}